<html>
	<head>

		<link rel="stylesheet" type = "text/css" href="leaflet/leaflet.css" />
   		<script src = "leaflet/leaflet.js"></script>
   		<script type="text/javascript" src="http://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js"></script>
		<script type="text/javascript" src="http://www.parsecdn.com/js/parse-1.2.13.min.js"></script>
		<script type="text/javascript" src="jquery-1.9.1.js"></script>
		<script type="text/javascript" src="jquery-ui-1.10.3.custom.js"></script>
		<script type="text/javascript" src="jquery.dataTables.js"></script>

   		<!--This defines some basic styles associated with the map and .info-->
   		<link rel="stylesheet" type="text/css" href="style.css">
   		</style>
		</head>
		<body>
		<div id="control">
			<img src="arctic_map.jpg">
		</div>
		<div id="map"></div>
		<!-- GeoJSON Data (countries-hires.js) -->
		<script type="text/javascript" src="countries-hires.js"></script>
		<script type="text/javascript" src="reports.js"></script>

		<!-- Our javascript code-->
		<script type="text/javascript">
			Parse.initialize("g9E0CvsnPFgymkq8FxTN0khh9FZ5sqbaqsoN6GfH", "R83Wi2r7ndSyA3gFUDqk6f3tZ9RP1Sn7WO3L9q3G");

			var points_list = [];
			var cloudmadeUrl = 'http://{s}.tile.cloudmade.com/e2c7205a90f64eec9d06b4f89e44ce0c/111453/256/{z}/{x}/{y}.png',
            cloudmadeAttribution = 'Map data &copy; 2011 OpenStreetMap contributors, Imagery &copy; 2011 CloudMade';
			var normal = L.tileLayer(cloudmadeUrl, {
			    attribution: 'Map data &copy; <a href="http://openstreetmap.org">OpenStreetMap</a> contributors, <a href="http://creativecommons.org/licenses/by-sa/2.0/">CC-BY-SA</a>, <img src="url" alt="some_text">Imagery Â© <a href="http://cloudmade.com">CloudMade</a>',
			    maxZoom: 18
			})// add a tile

			var info = L.control();
	
			info.onAdd = function (map) {
				this._div = L.DomUtil.create('div', 'info');
				this.update();
				return this._div;
			};
	
			info.update = function (props) {
				this._div.innerHTML = '<h4>World</h4>' +  (props ?
					'<b>' + props.NAME + '</b><br />'
					+ 'Reports'
					: 'Hover over a country');
			};
	
			function getColor(c) {
    			return c == 6  ? '#800026' :
			           c == 5  ? '#BD0026' :
			           c == 4  ? '#E31A1C' :
			           c == 3  ? '#FC4E2A' :
			           c == 2  ? '#FD8D3C' :
			           c == 1  ? '#FEB24C' :
			           c == 0  ? '#FED976' :
			                      '#FFEDA0';
			}

			function style(feature) {
			    return {
			        fillColor: getColor(feature.properties.MAP_COLOR),
			        weight: 2,
			        opacity: 1,
			        color: 'white',
			        dashArray: '3',
			        fillOpacity: 0.7
			    };
			}
			
			// Variables to hold the GeoJSON data for the countries and reports respectively
			var countries;
			var reports;

			// Function that will highlight a feature that is passed to it
			function highlightFeature(e) {
			    var layer = e.target;
			
			    layer.setStyle({
			        weight: 5,
			        color: '#666',
			        dashArray: '',
			        fillOpacity: 0.7
			    });
			
			    if (!L.Browser.ie && !L.Browser.opera) {
			        layer.bringToFront();
			    }
			    info.update(layer.feature.properties);
			}
			
			// Resets the highlight
			function resetHighlight(e) {
			    countries.resetStyle(e.target);
			    info.update();
			}
			
			// Acquires the bounds of a feature e and zooms in on them
			function zoomToFeature(e) {
				map.fitBounds(e.target.getBounds());
			}
			
			// Takes a feature and a layer and highlights the feature while mouse is on it
			// Also zooms on to the feature when the feature is clicked
			function onEachFeature(feature, layer) {
				layer.on({
					mouseover: highlightFeature,
					mouseout: resetHighlight,
					click: zoomToFeature
				});
			}


			// Adding in an icon
			var blackIcon = L.icon({
				iconUrl: 'black-dot.png',
			    iconSize:     [6, 6], // size of the icon
			    shadowSize:   [0, 0], // size of the shadow
			    iconAnchor:   [3, 3], // point of the icon which will correspond to marker's location
			    shadowAnchor: [4, 62],  // the same for the shadow
			    popupAnchor:  [-3, -76] // point from which the popup should open relative to the iconAnchor
			});

			// Creating a geoJSON layer for the country data with highlight and zoom capabilities
			countries = L.geoJson(countryData, {
				style: style,
				onEachFeature: onEachFeature
			});


			/* Creating a geoJSON layer for the report data with custom icon.
			Has highlight and zoom capabilities. */
			reports = L.geoJson(pointsData, {
				style: style,
				pointToLayer: function(feature, latlng) {
					return L.marker(latlng); //, {icon: blackIcon});
				},
				onEachFeature: onEachFeature
			});

			conferences = L.geoJson(null, {
				pointToLayer: function(feature, latlng) {
					return new L.Marker(latlng)
				},
				onEachFeature: onEachFeature
			});


			var Conference = Parse.Object.extend("Conference");
    		var query = new Parse.Query(Conference);
		    function getAllConferences() {
		    	query.find({
			      success: function(results) {

			        // Do something with the returned Parse.Object values
			        for (var i = 0; i < results.length; i++) {
			        	var latitude = results[i].get('latitude');
			        	alert(latitude);
			        	var longitude = results[i].get('longitude');
			        	var point = {
			        		"type": "Feature",
			        		"id": i,
			        		"geometry": {
			        			"type": "Point",
			        			"coordinates": [latitude, longitude]
			        		},
			        		"properties": {
			        			"LATITUDE": latitude,
			        			"LONGITUDE": longitude
			        		}
			        		
			        	};	
			        	conferences.addData(point);		        	
			        }
			        
			      },

			      error: function(error) {}
				});
		    }

		    getAllConferences();

		    
			// Initialize the map with center location and zoom level.
			var map = L.map('map', {
				center: new L.LatLng(66, 0),
                zoom: 1,
                maxZoom: 8,
                minZoom: 0,
				layers: [normal, countries, reports]
			});

			var geojsonMarkerOptions = {
				radius: 60,
				fillColor: "#ff7800",
				color: "#000",
				weight: 1,
				opacity: 5,
				fillOpacity: .8
			};
			// Add info control to the map
			info.addTo(map);

			var baseMaps = {
            	"Normal": normal
            };
        
            var overlayMaps = {
            	"countries": countries,
            	"reports": reports,
            	"conferences": conferences
            };



			// Events

			// Add a layer controller to the map
			L.control.layers(baseMaps, overlayMaps).addTo(map);
			
			// When the map is clicked, initialize an icon
			function onMapClick(e) {
				var maker = L.marker(e.latlng, {icon: blackIcon}).addTo(map);

				/*// Draw two points
				points_list.push(e.latlng);
				if(points_list.length % 2 == 1){
					//draw nothing
				}else{
					//draw a line
					var latlngs = [];
					latlngs.push(e.latlng);
					points_list.pop();
					latlngs.push(points_list.pop());
					// create a red polyline from an arrays of LatLng points
					var polyline = L.polyline(latlngs, {color: 'red'}).addTo(map);
					
					// zoom the map to the polyline
					//map.fitBounds(polyline.getBounds());
					
					
					//draw curves
					
				}*/
			}

			map.on('click', onMapClick);
		</script>
	</body>
</html>